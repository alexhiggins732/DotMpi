<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
using System.IO.Pipes;
using System.Text;


namespace DotMpi
{
    public partial class Mpi
    {

    #region ParallelFor

    <#
	    for(var i=0; i<16;i++)
	    {#>


        /// <summary>
        /// Multi processor parallel runner, accepting an argument provider
        /// </summary>
        /// <param name="fromInclusive">The start index, inclusive.</param>
        /// <param name="toExclusive">The end index, exclusive.</param>
        /// <param name="target">The target method to execute on the external processor.</param>
        /// <param name="argProvider">Delegate function to provide arguments for each process.</param>
        /// <exception cref="ArgumentException"></exception>
        public static ParallelFunction<<#	for(var j=0; j<=i;j++){#>T<#=j#>, <#}#>TResult>
            ParallelFor<<#	for(var j=0; j<=i;j++){#>T<#=j#>, <#}#>TResult>(
                int fromInclusive,
                int toExclusive,
                Func<<#	for(var j=0; j<=i;j++){#>T<#=j#>, <#}#>TResult> target,
                Func<int, ArgList<<#	for(var j=0; j<=i;j++){#>T<#=j#><#if(j<i){#>, <#}#><#}#>>> argProvider
            )
        {
            var builder = new ParallelFunctionBuilder(fromInclusive, toExclusive)
                .For(target, argProvider);
            return builder;
        }



        /// <summary>
        /// Multi processor parallel runner, accepting an strongly typed generic arguments
        /// </summary>
        /// <param name="fromInclusive">The start index, inclusive.</param>
        /// <param name="toExclusive">The end index, exclusive.</param>
        /// <param name="target">The target method to execute on the external processor.</param>
        /// <exception cref="ArgumentException"></exception>
        public static ParallelFunction<<#	for(var j=0; j<=i;j++){#>T<#=j#>, <#}#>TResult>
            ParallelFor<<#	for(var j=0; j<=i;j++){#>T<#=j#>, <#}#>TResult>(
                int fromInclusive,
                int toExclusive,
                Func<<#	for(var j=0; j<=i;j++){#>T<#=j#>, <#}#>TResult> target,
                <#	for(var j=0; j<=i;j++){#>T<#=j#> arg<#=j#><#if(j<i){#>, <#}#><#}#>
            )
        {
            var builder = new ParallelFunctionBuilder(fromInclusive, toExclusive)
                .For(target).WithArgs((i => new(<#	for(var j=0; j<=i;j++){#>arg<#=j#><#if(j<i){#>, <#}#><#}#>)));
            return builder;
        }

        <#}#>

    #endregion



    #region ParallelFunctionBuilder.For

        public partial class ParallelFunctionBuilder
        {
<#
	    for(var i=0; i<16;i++)
	    {#>

            /// <summary>
            /// Multi processor parallel runner, accepting an argument provider
            /// </summary>
            /// <param name="target">The target method to execute on the external processor.</param>
            /// <param name="argProvider">Delegate function to provide arguments for each process.</param>
            public ParallelFunction
                <<#	for(var j=0; j<=i;j++){#>T<#=j#>, <#}#>TResult>
                For<<#	for(var j=0; j<=i;j++){#>T<#=j#>, <#}#>TResult>
                (
                    Func<<#	for(var j=0; j<=i;j++){#>T<#=j#>, <#}#>TResult> target
                )
                {
                    var runner = new ParallelFunction<<#	for(var j=0; j<=i;j++){#>T<#=j#>, <#}#>TResult>
                        (Start, End, target);
                    return runner;                
                }

            /// <summary>
            /// Multi processor parallel runner, accepting an argument provider
            /// </summary>
            /// <param name="target">The target method to execute on the external processor.</param>
            /// <param name="argProvider">Delegate function to provide arguments for each process.</param>
            public ParallelFunction
                <<#	for(var j=0; j<=i;j++){#>T<#=j#>, <#}#>TResult>
                For<<#	for(var j=0; j<=i;j++){#>T<#=j#>, <#}#>TResult>
                (
                    Func<<#	for(var j=0; j<=i;j++){#>T<#=j#>, <#}#>TResult> target,
                    Func<int, ArgList<<#	for(var j=0; j<=i;j++){#>T<#=j#><#if(j<i){#>, <#}#><#}#>>> argProvider
                )
                {
                    var runner = new ParallelFunction<<#	for(var j=0; j<=i;j++){#>T<#=j#>, <#}#>TResult>
                        (Start, End, target);

                    return runner.WithArgs(argProvider);                
                }

        <#}#>
        }

    #endregion



    #region ParallelFunction

#pragma warning disable CS8601 // Possible null reference assignment.
#pragma warning disable CS8604 // Possible null reference argument.
#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
<#
	    for(var i=0; i<16;i++)
	    {#>

        /// <summary>
        /// Multi processor parallel runner
        /// </summary>
        public class ParallelFunction<<#	for(var j=0; j<=i;j++){#>T<#=j#>, <#}#>TResult> 
            : ParallelFunctionRunner<TResult>
        {

            private Func<int, ArgList<<#	for(var j=0; j<=i;j++){#>T<#=j#><#if(j<i){#>, <#}#><#}#>>> argProvider = null!;

            /// <summary>
            /// Multi processor parallel runner
            /// </summary>
            /// <param name="fromInclusive">The start index, inclusive.</param>
            /// <param name="toExclusive">The end index, exclusive.</param>
            /// <exception cref="ArgumentException"></exception>
            public ParallelFunction(int fromInclusive, int toExclusive, Func<<#for(var j=0; j<=i;j++){#>T<#=j#>, <#}#>TResult> target)
                : base(fromInclusive, toExclusive)
            {
                Target = target;
            }

            public Func<<#	for(var j=0; j<=i;j++){#>T<#=j#>, <#}#>TResult> Target { get; }

            public TResult Execute(<#	for(var j=0; j<=i;j++){#>T<#=j#> arg<#=j#><#if(j<i){#>, <#}#><#}#>)
            {
                var result = MpiRunner.Exec(Target, <#	for(var j=0; j<=i;j++){#>arg<#=j#><#if(j<i){#>, <#}#><#}#>);
                return result;
            }

            <#if(i==0){#>

            /// <summary>
            /// Registers a delegate function to provide arguments for each process.
            /// </summary>
            /// <param name="argProvider">Delegate function to provide arguments for each process.</param>
            /// <returns></returns>
            public ParallelFunction<<#for(var j=0; j<=i;j++){#>T<#=j#>, <#}#>TResult> 
                WithArgs(Func<int, T0> value)
            {
                this.argProvider= (i => new(value(i)));
                this.ArgProvider = this.argProvider;
                return this;
            }

            <#}#>

            /// <summary>
            /// Registers a strongly typed generic arguments to provide to each process
            /// </summary>
            /// <returns></returns>
            public ParallelFunction<<#for(var j=0; j<=i;j++){#>T<#=j#>, <#}#>TResult> 
                WithArgs(<#	for(var j=0; j<=i;j++){#>T<#=j#> arg<#=j#><#if(j<i){#>, <#}#><#}#>)
            {
                this.argProvider = (i => new(<#	for(var j=0; j<=i;j++){#>arg<#=j#><#if(j<i){#>, <#}#><#}#>));
                this.ArgProvider = this.argProvider;
                return this;
            }
          
            /// <summary>
            /// Registers a delegate function to provide arguments for each process.
            /// </summary>
            /// <param name="argProvider">Delegate function to provide arguments for each process.</param>
            /// <returns></returns>
            public ParallelFunction<<#for(var j=0; j<=i;j++){#>T<#=j#>, <#}#>TResult>
                WithArgs(Func<int, ArgList<<#	for(var j=0; j<=i;j++){#>T<#=j#><#if(j<i){#>, <#}#><#}#>>> argProvider)
            {
                this.argProvider = argProvider;
                this.ArgProvider = this.argProvider;
                return this;
            }

            protected override void RunThread(NamedPipeServerStream pipeServer, string pipeName, int threadIndex, Func<int, IArgListProvider> argProvider)
            {
                var args = argProvider(threadIndex).ToArray();


                Console.WriteLine($"[{DateTime.Now}] {id} [Thread {threadIndex}] Executing ParallelRunner.{nameof(Run)}(pipeServer, {pipeName}, {string.Join(",", args)})");
                Console.WriteLine($"[{DateTime.Now}] {id} Executing ParallelRunner:PipeServer.WaitForConnection()");

                pipeServer.WaitForConnection();



                var callData = MpiRunner.GetRemoteCallData(Target.Method, args);

                if (Logger.InfoEnabled)
                {
                    var debugJson = callData.DebugJson();
                    Logger.Info($"[{DateTime.Now}] {id} Sending call data to {pipeName} {threadIndex}: {debugJson}");
                }

                if(args!=null && args.Length> 0 && (int)args[0] != threadIndex)
                {
                    throw new Exception("Invalid arg for {threadIndex}: {args[0]}");
                }

                using (var bw = new BinaryWriter(pipeServer, Encoding.UTF8, true))
                {
                    byte[] callDataBytes = callData.ToByteArray();
                    bw.Write(callDataBytes.Length);
                    bw.Write(callDataBytes);
                }
                
                // will be executed remote on the client.
                //ExecuteAndSend(pipeName);
            }
        }

<#
        }
#>
#pragma warning restore CS8601 // Possible null reference assignment.
#pragma warning restore CS8604 // Possible null reference argument.
#pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
 
    #endregion

    }
}